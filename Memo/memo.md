# 0630
kernel_imageだけjosのものにして、残り２つはxv6のものをそのまま流用しても、josが動いた

# fs.img
```mkfs fs.img <size>```で作成できる。

# jos
## josの物理メモリ
josは使用可能な物理メモリの範囲を、NVRAMの適切な領域を読むことによって調べる。
BIOSが起動時に使用可能なRAMの範囲を調べ、その情報をNVRAMに書き込む。
モダンなシステムでは、UEFIファームウェアがこの情報を然るべき領域に保存し、OSがそれを読み取ることができるようにする。(NVRAMを通さなくて済む)

## josを動かすには
kvmmではNVRAMをエミュレートしていないので、josは物理メモリの範囲を調べることができない。
kvmを走らせる時に指定するゲストの物理メモリの量を確認して、それに合わせてnpagesとかの変数に適当な値を入れてやるのが良さそう？
(ioctlの引数としてkvmに渡している？)

## kvmの物理メモリ
ioctlでKVM_SET_USER_MEMORY_REGIONを呼び出すことで、物理メモリの範囲を指定できる。

# kvmの処理のコア部分(intel)
結局ゲストの実行というのは、ゲスト用のレジスタの値を実際のレジスタにロードして行うという、コンテキストスイッチのときと同じこと。(kvmの場合はcpuのモード変更とかあるけど)
<br>
kvmのコアの処理も、準備->実行(コンテキストスイッチ)->exitしたらハンドリングという流れで、VMMと同じ流れの処理の、一歩中側のことをやってるだけ。
VMRESUMEとかVMLAUNCHとかいう命令の中で、ゲストのコードが実行される。
exitしたら、VMCSのexit_reasonを見て、それに応じた処理をする。(詳細はVMM側に任せるが)

IPなどのレジスタに関しては、VMCS領域に保存されており、VMenter/exitのタイミングで自動で切り替えられる。
VMCSという領域は、ホストからもゲストからも使えるので、シームレスに入れ替えることができる。
vmwrite/vmreadという命令で、VMCSの領域にアクセスできる。
<br>
VMexitの条件も、VMCSの中のVM-excution control fieldsという領域に保存されている。